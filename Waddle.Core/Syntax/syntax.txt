program :=
    functionDecl*

functionDecl :=
    voidFuction
    returnFunction

voidFuction :=
    FUNCTION IDENT LPAREN parameterList RPAREN block

returnFunction :=
    FUNCTION IDENT LPAREN parameterList RPAREN ARROW type block

block :=
    LBRACE statement* RBRACE

parameterList :=
    parameterDef [0..1] ("," parameterDef)*

parameterDef :=
    IDENTIFIER COLON type

statement :=
    printStmt
    returnStmt
    assignStmt
    forStmt
    bindingStmt
    varDeclStmt
    ifStmt
    matchStmt
    pushStmnt
    lengthStmt

printStmt:=
    PRINT LPAREN STRING RPAREN

returnStmt:=
    RETURN (returnFunction | varDeclStmt | IDENTIFIER)

assignStmt :=
    IDENTIFIER EQ expression

forStmt :=
    FOR LPAREN iterationDef RPAREN block

iterationDef :=
    varDeclStmt SEMICOLON relationalExpr SEMICOLON assignStmt

bindingStmt :=
    LET IDENTIFIER COLON type (EQ expression)?

varDeclStmt :=
    VAR IDENTIFIER COLON type (EQ expression)?

expression :=
    relationalExpr (conditionalOp relationalExpr)*

ifStmt :=
    IF LPAREN expression RPAREN block

matchStmt :=
    MATCH LPAREN (IDENTIFIER | STRING) RPAREN matchDef

matchDef :=
    LBRACE (matchValue ",")* RBRACE

matchValue :=
    STRING ARROW STRING

conditionalOp :=
    AND
    OR

relationalExpr :=
    termExpr (relationalOp termExpr)?

relationalOp :=
    LT
    GT
    LE
    EQ
    ...

...

atom :=
    ARROW
    COLON
    SEMICOLON
    IDENTIFIER
    STRING
    NUMBER
    ...